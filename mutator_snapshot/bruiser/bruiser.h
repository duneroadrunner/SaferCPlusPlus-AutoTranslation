
/***************************************************Project Mutator****************************************************/
//-*-c++-*-
/*first line intentionally left blank.*/
/*the header for bruiser's main.*/
/*Copyright (C) 2017 Farzad Sadeghi

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.*/
/*code structure inspired by Eli Bendersky's tutorial on Rewriters.*/
/**********************************************************************************************************************/
/*inclusion guard*/
#ifndef BRUISER_H
#define BRUISER_H
/**********************************************************************************************************************/
/*included modules*/
/*project headers*/
#include "../tinyxml2/tinyxml2.h"
/*standard library headers*/
#include <string>
#include <fstream>
/*clang headers*/
#include "clang/AST/ASTContext.h"
#include "clang/AST/Expr.h"
#include "clang/AST/Type.h"
#include "clang/AST/ASTTypeTraits.h"
/*llvm headers*/
/**********************************************************************************************************************/
/*using*/
using namespace tinyxml2;
using namespace llvm;
using namespace clang;
/**********************************************************************************************************************/
namespace bruiser
{ //start of namespace bruiser
/**********************************************************************************************************************/
  const char* M0REP = "../test/misrareport.xml";
/**********************************************************************************************************************/
#define RED "\033[1;31m"
#define CYAN "\033[1;36m"
#define GREEN "\033[1;32m"
#define BLUE "\033[1;34m"
#define BLACK "\033[1;30m"
#define BROWN "\033[1;33m"
#define MAGENTA "\033[1;35m"
#define GRAY "\033[1;37m"
#define DARKGRAY "\033[1;30m"
#define YELLOW "\033[1;33m"
#define NORMAL "\033[0m"
#define CLEAR	"\033[2J"

#define LN_RED 31
#define LN_GREEN 32
#define LN_YELLOW 33
#define LN_BLUE 34
#define LN_MAGENTA 35
#define LN_CYAN 36
#define LN_WHITE 37

#define BOLD 1
#define NO_BOLD 0

#define SHELL_HISTORY_SIZE  100
#define SHELL_HISTORY_FILE "bruiser-history.txt"

#define GLOBAL_TIME_OUT 100000

#define NOT_IMPLEMENTED \
  do{\
    printf(BROWN "not implemented yet.");\
    printf(NORMAL"\n");\
  }while(0)

#define  PRINT_WITH_COLOR(X,Y) \
  do{\
    printf(X Y NORMAL);\
  }while(0)

#define  PRINT_WITH_COLOR_LB(X,Y) \
  do{\
    printf(X "%s", Y);\
    printf(NORMAL"\n");\
  }while(0)
/**********************************************************************************************************************/
/*Error Codes*/
#define M0_ERROR_CODES \
  X(BAD_M0_XML, "bad m0 xml.", 100) \
  X(CANT_OPEN_M0_XML, "could not open m0 xml.", 101) \

#define X(__x1, __x2, __x3) __x1,
  enum class M0_ERR {M0_ERROR_CODES};
#undef X
/**********************************************************************************************************************/
/*Enums*/
/**********************************************************************************************************************/
struct help
{
  public:
    std::string name;
    std::string proto;
    std::string descr;
    std::string protoprefix;
    std::string retval;
};

help CMDHelp[] = {
  {"help()", "help()", "display general help", "none", "none"},
  {"quit()", "quit()", "quit bruiser", "none", "none"},
  {"exit()", "exit()", "quit bruiser", "none", "none"},
  {"m0()", "m0()", "bruiser reads the report generated by mutator-lvl0", "", ""},
  {"readxmlfile()", "readxmlfile(\"myxml.xml\")", "bruiser reads the specified xml file, if no argument is provided bruiser tries to read the m0 report at the default location", "", "tinyxml2::XMLError"},
  {"hijackmain()", "hijackmain()", "runs a specific matcher that replaces the main with a new main", "none", "returns the rewritten source code as a string"},
  {"clear()", "clear()", "clears the terminal", "", "none"},
  {"history()", "", "prints bruiser's history", "", "none"},
  {"!", "", "prints the command from history", "", "none"},
  {"Vars()", "", "lists all available variable declarations", "none", "returns a string array of the variable declarations"},
  {"Funcs()", "", "lists all available function declarations", "none", "returns a string array of the function declarations"},
  {"Classess()", "", "lists all available class declarations", "none", "returns a string array of the class declarations"},
  {"Structs()", "", "lists all available struct declarations", "none", "returns a string array of the structure declarations"},
  {"Arrays()", "", "lists all available array declarations", "none", "returns a string array of the array declarations"},
  {"Unions()", "", "lists all available union declarations", "none", "returns a string array of the union declarations"},
  {"make()", "make(\"all\")", "runs your make command", "", ""},
  {"historysize()", "historysize(200)", "sets the history size", "[uint history_size]", "none"},
  {"showsource()", "showsource(1,5,\"test.cpp\")", "shows the source code for the given range and filename", "[uint beginline, uint endline, string filename]", "returns a string array of the returned source file"},
  {"extractmutagen()", "extractmutagen(\"test.cpp\")", "runs m0 on the source(s)", "[string]", "pid"},
  {"strainrecognition()", "", "", "", ""},
  {"setmakepath()", "setmakepath(\"../../myproject\")", "tells bruiser where to execute the make command run from make()", "string", "none"},
  {"run()", "run(\"myexecutable\")", "runs the mutant", "string", "return value"},
  {"setbinpath()", "setbinpath(\"bin_path\")", "sets the binary path for mutant executable", "string", "none"},
  {"getbinpath()", "getbinpath()", "gets the binary path for mutant executable", "none", "string"},
  {"getmakepath()", "getmakepath()", "gets the make path for mutant executable", "none", "string"},
  {"getpaths()", "getpaths()", "gets the currently loaded paths that bruiser looks through", "none", "array of strings"},
  {"getsourcefiles()", "getsourcefiles()", "gets the currently loaded source files that bruiser will look through", "none", "array of strings"},
  {"changedirectory()", "changedirectory()", "changes bruiser's working directory. only use it when you know what you are doing.", "destination directory, [string]", "return value"}
};
/**********************************************************************************************************************/
/**
 * @brief This class handles the logging for bruiser.
 */
class BruiserReport
{
  public:
    BruiserReport ();

    ~BruiserReport();

    template <typename T>
    bool PrintToLog(T __arg);

  private:
    std::ofstream BruiserLog;
};
/**********************************************************************************************************************/
/**
 * @brief looks through types.
 */
class TypeInfo
{
  public:
    explicit TypeInfo(const clang::ast_type_traits::DynTypedNode* __dtn);

    ~TypeInfo();

    const clang::Type* getTypeInfo(clang::ASTContext* __astc);

  private:
    const clang::ast_type_traits::DynTypedNode* DTN;
};
/**********************************************************************************************************************/
class ReadM0
{
  public:
    /*default ctor*/
    ReadM0()
    {
      try
      {
      XMLError eResult [[maybe_unused]] = IntermediateXMLDoc.LoadFile(M0REP);

      RootPointer = IntermediateXMLDoc.FirstChild();
      }
      catch (std::exception& e)
      {

      }
    }

    /*asks for the xml report you want to read*/
    ReadM0(const char* __xml_report_file)
    {
      try
      {
      XMLError eResult [[maybe_unused]] = IntermediateXMLDoc.LoadFile(__xml_report_file);

      RootPointer = IntermediateXMLDoc.FirstChild();
      }
      catch (std::exception& e)
      {

      }
    }

    ~ReadM0() {}

    XMLError LoadXMLDoc(void)
    {
      XMLError eResult = IntermediateXMLDoc.LoadFile(M0REP);

      return eResult;
    }

    XMLError ReadFirstElement(void)
    {
      RootPointer = IntermediateXMLDoc.FirstChild();

      if (RootPointer == nullptr)
      {
        return XML_ERROR_FILE_READ_ERROR;
      }
      else
      {
        return XML_SUCCESS;
      }
    }

    XMLNode* getRootPointer(void)
    {
      return RootPointer;
    }

  private:
    void Debug(void)
    {

    }

    XMLDocument IntermediateXMLDoc;
    XMLNode* RootPointer;
};
/**********************************************************************************************************************/
class SearchM0
{
  public:
    SearchM0(XMLNode* __rptr) : RootPointer(__rptr) {}

    ~SearchM0() {};

    void Debug(void)
    {
      if (!RootPointer->NoChildren())
      {
        const XMLElement* XMLE [[maybe_unused]] = RootPointer->FirstChildElement();

      }
    }

  private:
    XMLNode* RootPointer;
};
/**********************************************************************************************************************/
class Daemonize
{
  public:
    Daemonize (std::string __exe, std::string __opts) : Exe(__exe), Opts(__opts) {}



  private:
    std::string Exe;
    std::string Opts;
};
/**********************************************************************************************************************/
/**********************************************************************************************************************/
} // end of namespace bruiser
#endif
/*last line intentionally left balnk.*/

